import random
import re
import monsters
import encounter_tables
from bisect import bisect_left
from monsternew import cr_dict2
monster_data = {}
monsters_dict = {}

# This has been replaced with the encounter generation
Group = ["Goblins", "Lizardfolk", "Centaurs", "Kobolds", "Bugbears", "Hobgoblins", "Firborgs", "Fey", "Goliats", "Minotaurs", 
         "Owlbears", "Trolls", "Chimera", "Gnolls", "Vampires"]

# These are the base for the semantic part of the encounter generator, increase the number of "Monster" for more encounters
Attitude = ["friendly", "cautious", "indifferent", "hostile", "threatening"]
Need_Want = ["Food", "Mate", "Shiny things", "Slaves", "Territory", "Home", "Religious sacrifice", "status/trophies", "kicks/fun"]
Complication = ["Secretive", "Monster", "Monster", "Monster", "Monster", "Wounded", "Insane", "Controlled", "Supernatural", 
                "Trapped", "Frenzied", "with children", "Pregnant", "with prisoner", "with treasure", "Diseased", "Running", 
                "Hiding", "Lost"]
# Use this for only monster vs monster encounters: 
# Complication = ["Monster"]

# this is not in use anymore keep for a little while
class Monster:
    """Class used to rename values in the monsters.cr_dict dictionary."""
    def __init__(self, name, manpage, cr, xp, size, monster_type):
        self.name = name
        self.manpage = manpage
        self.cr = cr
        self.xp = xp
        self.size = size
        self.monster_type = monster_type

  

def xp_budget(party_size, party_level, difficulty):
    """Function which takes the party size, average party level, and desired difficulty to return the correct XP budget
    within the encounter_table dictionary.
    """
    if party_level > 20 or party_level < 1 or party_size < 1:
        raise ValueError('Party level should be between 1 and 20, while party size should be 1 or greater.')
    return (encounter_tables.xp_difficulties[difficulty][party_level - 1]) * party_size


def xp_list_gen(xp):
    """Function to find factors of the XP budget integer. Returns a random factor,
    so long as that factor pairing is < 21. This keeps the number of monsters manageable.
    """
    xp_factors = [i for i in range(10, xp + 1) if xp % i == 0]
    random_gen_factor = 0
    while random_gen_factor == 0 or (xp / random_gen_factor) > 20:
        random_gen_factor = random.choice(xp_factors)
    return random_gen_factor

def rnd_select_monster(xp, monster_type, input_monster_dict, environment_input):
    if environment_input == 'all':
        if monster_type == 'all':
            nearest_monster_xp = min(list_monster_xp(input_monster_dict, xp), key=lambda x: abs(x - xp))
            monster_selections = [key for key, data in input_monster_dict.items() if data['xp'] == nearest_monster_xp]
            if not monster_selections:
                return None  # No monster found
            output_monster = random.choice(list(monster_selections))
            return output_monster
        else:
            monster_type_dict = {key: data for key, data in input_monster_dict.items() if data['monster_type'] == monster_type.capitalize()}
            nearest_monster_xp = min([data['xp'] for key, data in monster_type_dict.items() if data['xp'] <= xp], key=lambda x: abs(x - xp))
            monster_selections = [key for key, data in monster_type_dict.items() if data['xp'] == nearest_monster_xp and data['monster_type'] == monster_type.capitalize()]
            if not monster_selections:
                return None  # No monster found
            output_monster = random.choice(list(monster_selections))
            return output_monster
    else:
        if monster_type == 'all':
            nearest_monster_xp = min(list_monster_xp(input_monster_dict, xp), key=lambda x: abs(x - xp))
            monster_selections = [key for key, data in input_monster_dict.items() if data['xp'] == nearest_monster_xp]
            environment_type_dict = {key: data for key, data in input_monster_dict.items() if environment_input.capitalize() in data['environment']}
            common_elements = set(monster_selections) & set(environment_type_dict.keys())
            if not common_elements:
                return None  # No monster found
            output_monster = random.choice(list(common_elements))
            return output_monster
        else:
            environment_type_dict = {key: data for key, data in input_monster_dict.items() if environment_input.capitalize() in data['environment'] and data['monster_type'] == monster_type.capitalize()}
            nearest_monster_xp = min([data['xp'] for key, data in environment_type_dict.items() if data['xp'] <= xp], key=lambda x: abs(x - xp))
            monster_selections = [key for key, data in environment_type_dict.items() if data['xp'] == nearest_monster_xp and data['monster_type'] == monster_type.capitalize()]
            common_elements = set(monster_selections) & set(environment_type_dict.keys())
            if not common_elements:
                return None  # No monster found
            output_monster = random.choice(list(common_elements))
            return output_monster




def list_monster_xp(input_monster_dict, xp):
    monster_xp_list = []
    for key in input_monster_dict:
        monster_data = input_monster_dict[key]
        if monster_data['xp'] <= xp:
            monster_xp_list.append(monster_data['xp'])
    return monster_xp_list


def build_encounter_size(party_size, monster_xp, xp):
    """Function returns number of monsters in encounter based on previous function outputs.
    The number of monsters depends upon the party size, and xp budget."""
    
    monster_count = [1, 2, 6, 10, 14]
    encounter_multiplier = [1.0, 0.67, 0.50, 0.40, 0.33, 0.25]
    num_monsters = xp // monster_xp
    # Use monster_count table to find correct index in encounter_multiplier.
    index_table = bisect_left(monster_count, num_monsters)
    if party_size <= 2 and index_table != len(encounter_multiplier) - 1:
        index_table += 1
    #if num_monsters == 1:
    #    return num_monsters
    return int(num_monsters * encounter_multiplier[index_table])  # number, xp value


def get_user_input_str(prompt, default_choice, choices=None):
    """Function returns a string based on input with exception check, so long as the input is one of a few choices."""
    result = None
    while result is None:
        val = input(prompt).lower()
        if val is '':
            result = default_choice
        elif choices and val not in choices:
            print(' Error: must choose one: {0}'.format(choices,))
        else:
            result = val
    return result


def get_user_input_int(prompt):
    """Function returns an integer based on input with exception checking."""
    result = None
    while result is None:
        try:
            result = int(input(prompt))
        except ValueError:
            print(' not an integer, try again...')
    return result


def get_user_input_vars():
    """Function grabs user input and returns formatted output for encounter building.
    User input selection is: Prompt text, default option, list of choices."""
    party_size_input = get_user_input_int('Party size?> ')
    party_level_input = get_user_input_int('Party average level?> ')
    difficulty_input = get_user_input_str('Select difficulty:\nEasy, [Medium], Hard, or Deadly> ',
                                          default_choice='medium', choices=['easy', 'medium', 'hard', 'deadly'])
    monster_type = get_user_input_str("Select monster type:'?' [All]> ", default_choice='all', choices=encounter_tables.monster_types_list)
    number_of_encounters_input = get_user_input_int('number of encounters?')
    enviroment_input = get_user_input_str("Select enviroment type:'?' [All]> ", default_choice='all', choices=encounter_tables.environment_list)
    return party_size_input, party_level_input, difficulty_input, monster_type, number_of_encounters_input, enviroment_input


## This creates a new encounter each time it is run based on the imput from the user

def encounter_generator(current_encounter):
    encounter_xp = xp_budget(current_encounter[0], current_encounter[1], current_encounter[2])
    xp_per_monster = xp_list_gen(encounter_xp)                    
    output_monster = rnd_select_monster(xp_per_monster, current_encounter[3], monster_data, current_encounter[5])
    output_encounter = build_encounter_size(current_encounter[0], monster_data[output_monster]['xp'], encounter_xp)    
    monster = '{0} {1}(s) [Source: {2}]'.format(output_encounter, output_monster, monster_data[output_monster]['source'])     
    return monster


# This generates the num number of encounter promts, if the encounter complication is a 
# monster it selects a monster from the table and a attitude aswell.
def start():
    current_encounter = get_user_input_vars()
    script_repeat = 'y'
    num = current_encounter[4]
    
# This takes the number of encounters selected and runs the party size and level and seeks a suitable encounter.
    while script_repeat == 'y' or script_repeat == 'yes':
        print('Randomized encounter based on:\nParty Size: {0}\nParty Level: {1}\nDifficulty: {2} \nNumber of encounters: {3}'.format(current_encounter[0], 
              current_encounter[1], current_encounter[2], current_encounter[4]))        
        for _ in range(num):
            complication = random.choice(Complication)
            if complication == "Monster":
                ## This creates two monster encounters since the complication is monster
                ## This is the first encounter
                monster = encounter_generator(current_encounter)
                
                ## This is the second encounter
                monster2 = encounter_generator(current_encounter)
                complication = random.choice(Attitude), monster2  
                
                ## This prints the encounter
                encounter = "There are ", monster, " that are ", random.choice(Attitude), ", they seek ", random.choice(Need_Want), ", but there are ", complication, ".", '\n'
                encounter = ''.join([str(element) for element in encounter])
                encounter = re.sub(r"[-\"#@;():'<>{}=~|.?]", "", encounter)
                print(encounter)   
                          
            else:  
                ## This creates the encounter if there is no monster complication
                monster = encounter_generator(current_encounter)
                encounter = "There are ", monster, " that are ", random.choice(Attitude), ", they seek ", random.choice(Need_Want), ", but they are ", complication, ".", '\n'
                encounter = ''.join([str(element) for element in encounter])
                encounter = re.sub(r"[-\"#@;():'<>{}=~|.?]", "", encounter)
                print(encounter)
        script_repeat = get_user_input_str('Run again? Y/N\n[Y]> ', default_choice='y', choices=['y', 'yes', 'n', 'no'])
        

#initialized the program
def main():
    for key in monsters.cr_dict:
        monsters_dict[key] = Monster(key, *monsters.cr_dict[key])
        
    # Populate the monster_data dictionary from cr_dict2
    for key, value in cr_dict2.items():
        name = key
        size = value[0]
        monster_type = value[1]
        alignment = value[2]
        cr = value[3]
        xp = value[4]
        source = value[5]
        environments = value[6]

        environment_list = ['Arctic', 'Coastal', 'Desert', 'Forest', 'Grassland', 'Hill', 'Mountain',
                            'Swamp', 'Underdark', 'Underwater', 'Urban', 'Other Plane']

        environment_dict = {environment: (presence == 'x') for environment, presence in zip(environment_list, environments)}
        
        monster_data[name] = {
            'name': name,
            'size': size,
            'monster_type': monster_type,
            'alignment': alignment,
            'cr': cr,
            'xp': xp,
            'source': source,
            'environment': environment_dict
        }
    start()

# runs the script
if __name__ == '__main__':
    main()
